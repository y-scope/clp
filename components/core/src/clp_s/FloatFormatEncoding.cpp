#include "FloatFormatEncoding.hpp"

#include <cstdint>
#include <iomanip>
#include <ios>
#include <sstream>
#include <string>
#include <string_view>
#include <system_error>

#include <ystdlib/error_handling/Result.hpp>

namespace clp_s::float_format_encoding {
namespace {
auto has_exponent_sign(uint16_t format, uint16_t sign) -> bool;
auto has_scientific_notation(uint16_t format) -> bool;
auto is_uppercase_exponent(uint16_t format) -> bool;

auto get_exponent_digits(uint16_t format) -> uint16_t;
auto get_significant_digits(uint16_t format) -> uint16_t;

/**
 * Trims the leading zeros until the number of exponent digits match the value stored in the
 * format. The function attempts to remove up to the difference between current number of
 * exponent digits and leading zeros from the target value stored in the format from the
 * exponent, but stops early if a non-zero digit is encountered to preserve correctness.
 *
 * @param scientific_notation The scientific notation string generated by std::scientific.
 * @param start The start position of trimming. It could be either right after the exponent
 * note (E or e), or the second char after the exponent note if the exponent has a sign.
 * @param exp_digits The number of exponent digits stored in the format.
 * @return The scientific notation string with the exponent being trimmed leading zeros.
 */
auto trim_leading_zeros(std::string_view scientific_notation, size_t start, size_t exp_digits)
        -> std::string;

/**
 * Convert the scientific notation string to a double value string formatted by the encoded
 * format information.
 *
 * @param scientific_notation The scientific notation string generated by std::scientific.
 * @return The double value string formatted by the format information.
 */
auto scientific_to_decimal(std::string_view scientific_notation) -> std::string;

auto has_exponent_sign(uint16_t format, uint16_t sign) -> bool {
    return sign << cExponentSignPos == (format & 0b11 << cExponentSignPos);
}

auto has_scientific_notation(uint16_t format) -> bool {
    return format & 1 << float_format_encoding::cExponentNotationPos;
}

auto is_uppercase_exponent(uint16_t format) -> bool {
    return format << (float_format_encoding::cExponentNotationPos + 1);
}

auto get_exponent_digits(uint16_t format) -> uint16_t {
    return (format >> float_format_encoding::cNumExponentDigitsPos & 0x03) + 1;
}

auto get_significant_digits(uint16_t format) -> uint16_t {
    return (format >> float_format_encoding::cNumSignificantDigitsPos & 0x0F) + 1;
}

auto trim_leading_zeros(std::string_view scientific_notation, size_t start, size_t exp_digits)
        -> std::string {
    auto sci_str = std::string(scientific_notation);
    size_t actual_number_of_zeros_to_trim{0};
    for (size_t i{start}; i < sci_str.length() - exp_digits; ++i) {
        if ('0' == sci_str[i]) {
            actual_number_of_zeros_to_trim++;
        } else {
            break;
        }
    }
    sci_str.erase(start, actual_number_of_zeros_to_trim);
    return sci_str;
}

auto scientific_to_decimal(std::string_view scientific_notation) -> std::string {
    auto sci_str = std::string(scientific_notation);
    bool isNegative = false;
    if (false == std::isdigit(static_cast<unsigned char>(sci_str[0]))) {
        isNegative = true;
        sci_str.erase(0, 1);
    }
    size_t const exp_pos = sci_str.find_first_of("Ee");
    assert(std::string::npos != exp_pos && exp_pos + 1 < sci_str.length());

    // Split into mantissa and exponent parts
    std::string mantissa_str = sci_str.substr(0, exp_pos);
    int const exponent = std::stoi(sci_str.substr(exp_pos + 1));

    // Remove the decimal point from the mantissa
    size_t const dot_pos = mantissa_str.find('.');
    std::string digits;
    if (dot_pos != std::string::npos) {
        digits = mantissa_str.substr(0, dot_pos) + mantissa_str.substr(dot_pos + 1);
    } else {
        digits = mantissa_str;
    }

    // Adjust position of decimal point based on exponent
    int const decimal_pos
            = std::string::npos == dot_pos ? exponent + 1 : static_cast<int>(dot_pos) + exponent;

    std::string result{""};
    if (isNegative) {
        result = "-";
    }
    if (decimal_pos <= 0) {
        result += "0." + std::string(-decimal_pos, '0') + digits;
    } else if (decimal_pos < static_cast<int>(digits.size())) {
        result += digits.substr(0, decimal_pos) + "." + digits.substr(decimal_pos);
    } else {
        result += digits + std::string(decimal_pos - digits.size(), '0');
    }

    return result;
}
}  // namespace

auto get_float_encoding(std::string_view float_str) -> ystdlib::error_handling::Result<uint16_t> {
    auto const dot_pos{float_str.find('.')};
    uint16_t format{0};

    // Check whether it is scientific; if so, whether the exponent is E or e
    size_t exp_pos{float_str.find_first_of("Ee")};
    if (std::string_view::npos != exp_pos) {
        // Exponent must be followed by an integer (e.g., "1E" or "1e+" are illegal)
        if (false
            == ((exp_pos + 1 < float_str.length() && std::isdigit(float_str[exp_pos + 1]))
                || (exp_pos + 2 < float_str.length()
                    && ('+' == float_str[exp_pos + 1] || '-' == float_str[exp_pos + 1])
                    && std::isdigit(static_cast<unsigned char>(float_str[exp_pos + 2])))))
        {
            return std::errc::protocol_not_supported;
        }

        format |= static_cast<uint16_t>(1u) << cExponentNotationPos;
        format |= static_cast<uint16_t>('E' == float_str[exp_pos] ? 1u : 0u)
                  << (cExponentNotationPos + 1);

        // Check whether there is a sign for the exponent
        if ('+' == float_str[exp_pos + 1]) {
            format |= static_cast<uint16_t>(1u) << cExponentSignPos;
        } else if ('-' == float_str[exp_pos + 1]) {
            format |= static_cast<uint16_t>(1u) << (cExponentSignPos + 1);
        }

        // Set the number of exponent digits
        int exp_digits = float_str.length() - exp_pos - 1;
        if (false == std::isdigit(static_cast<unsigned char>(float_str[exp_pos + 1]))) {
            exp_digits--;
        }
        format |= (static_cast<uint16_t>(std::min(exp_digits - 1, 3)) & static_cast<uint16_t>(0x03))
                  << cNumExponentDigitsPos;
    } else {
        exp_pos = float_str.length();
    }

    // Find first non-zero digit position
    size_t first_non_zero_frac_digit_pos{0ULL};
    if (false == std::isdigit(static_cast<unsigned char>(float_str[0]))) {
        first_non_zero_frac_digit_pos = 1;  // Skip sign
    }

    if ('0' == float_str[first_non_zero_frac_digit_pos]) {
        // We don't support prefix zeroes of the form 0N.Y
        if (first_non_zero_frac_digit_pos + 1 < float_str.length()
            && std::isdigit(
                    static_cast<unsigned char>(float_str[first_non_zero_frac_digit_pos + 1])
            ))
        {
            return std::errc::protocol_not_supported;
        }

        // For "0.xxx", find the first non-zero digit after the decimal
        if (std::string_view::npos != dot_pos) {
            for (size_t i{dot_pos + 1}; i < exp_pos; ++i) {
                if ('0' != float_str[i]) {
                    first_non_zero_frac_digit_pos = i;
                    break;
                }
            }
        }
    }

    if (first_non_zero_frac_digit_pos >= exp_pos) {
        return std::errc::protocol_not_supported;
    }

    auto significant_digits{exp_pos - first_non_zero_frac_digit_pos};
    if (std::string_view::npos != dot_pos && first_non_zero_frac_digit_pos < dot_pos) {
        significant_digits--;
    }

    // Number of significant digits must be greater than zero (e.g., E0 or . is illegal)
    if (significant_digits <= 0) {
        return std::errc::protocol_not_supported;
    }
    uint16_t const compressed_significant_digits{
            static_cast<uint16_t>(std::min(significant_digits - 1ULL, 15ULL))
    };

    format |= compressed_significant_digits << cNumSignificantDigitsPos;
    return format;
}

auto restore_encoded_float(double value, uint16_t format) -> std::string {
    std::ostringstream oss;
    uint16_t const significant_digits = get_significant_digits(format);
    oss << std::scientific << std::setprecision(significant_digits - 1);
    if (has_scientific_notation(format)) {
        if (is_uppercase_exponent(format)) {
            oss << std::uppercase;
        }
        oss << value;
        auto formatted_double_str = oss.str();
        auto const exp_pos = formatted_double_str.find_first_of("Ee");
        assert(std::string::npos != exp_pos && exp_pos + 1 < formatted_double_str.length());
        unsigned char const maybe_sign
                = static_cast<unsigned char>(formatted_double_str[exp_pos + 1]);
        uint16_t const exp_digits = get_exponent_digits(format);
        if (has_exponent_sign(format, float_format_encoding::cEmptyExponentSign)) {
            if ('+' == maybe_sign || '-' == maybe_sign) {
                formatted_double_str.erase(exp_pos + 1, 1);
            }
            if (exp_digits < (formatted_double_str.length() - exp_pos - 1)) {
                formatted_double_str
                        = trim_leading_zeros(formatted_double_str, exp_pos + 1, exp_digits);
            } else {
                formatted_double_str.insert(
                        exp_pos + 1,
                        exp_digits - (formatted_double_str.length() - exp_pos - 1),
                        '0'
                );
            }
        } else {
            if (exp_digits < (formatted_double_str.length() - exp_pos - 2)) {
                formatted_double_str
                        = trim_leading_zeros(formatted_double_str, exp_pos + 2, exp_digits);
            } else {
                formatted_double_str.insert(
                        exp_pos + 2,
                        exp_digits - (formatted_double_str.length() - exp_pos - 2),
                        '0'
                );
            }
            if (has_exponent_sign(format, float_format_encoding::cPlusExponentSign)) {
                if (std::isdigit(maybe_sign)) {
                    formatted_double_str.insert(exp_pos + 1, "+");
                } else {
                    formatted_double_str[exp_pos + 1] = '+';
                }
            } else if (has_exponent_sign(format, float_format_encoding::cMinusExponentSign)) {
                if (std::isdigit(maybe_sign)) {
                    formatted_double_str.insert(exp_pos + 1, "-");
                } else {
                    formatted_double_str[exp_pos + 1] = '-';
                }
            }
        }

        return formatted_double_str;
    }

    // Convert the scientific notation to the standard decimal
    oss << value;
    return scientific_to_decimal(oss.str());
}
}  // namespace clp_s::float_format_encoding
