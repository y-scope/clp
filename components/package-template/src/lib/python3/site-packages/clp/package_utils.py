import enum
import json
import pathlib
import secrets
import socket
import subprocess
from contextlib import closing

from clp_py_utils.clp_config import ArchiveOutput, CLPConfig, Database, Scheduler, SchedulerQueue
from clp_py_utils.core import read_yaml_config_file

CONTAINER_CLP_INSTALL_PREFIX = '/opt'

DOCKER_MOUNT_TYPE_STRINGS = [
    'bind'
]


class DockerMountType(enum.IntEnum):
    BIND = 0


class DockerMount:
    def __init__(self, type: DockerMountType, src: pathlib.Path, dst: pathlib.Path, is_read_only: bool = False):
        self.__type = type
        self.__src = src
        self.__dst = dst
        self.__is_read_only = is_read_only

    def __str__(self):
        mount_str = f'type={DOCKER_MOUNT_TYPE_STRINGS[self.__type]},src={self.__src},dst={self.__dst}'
        if self.__is_read_only:
            mount_str += ',readonly'
        return mount_str


def check_dependencies():
    try:
        subprocess.run('command -v docker', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True)
    except subprocess.CalledProcessError:
        raise EnvironmentError('docker is not installed or available on the path')
    try:
        subprocess.run(['docker', 'ps'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True)
    except subprocess.CalledProcessError:
        raise EnvironmentError('docker cannot run without superuser privileges (sudo).')


def check_env(cluster_name: str):
    check_docker_network_bridge_cmd = ['docker', 'network', 'inspect', cluster_name]
    proc = subprocess.run(check_docker_network_bridge_cmd, stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE)
    if 0 != proc.returncode:
        raise EnvironmentError(f'Failed to inspect docker network bridge {cluster_name}')

    bridge_bridge_specification = json.loads(proc.stdout.decode('utf-8'))[0]
    required_containers = {cluster_name}
    for container_id, container in bridge_bridge_specification['Containers'].items():
        try:
            required_containers.remove(container['Name'])
        except KeyError:
            pass

    if required_containers:
        raise EnvironmentError(f'The required container is not started: {",".join(required_containers)}')


def generate_container_config(clp_config: CLPConfig, clp_home: pathlib.Path):
    # Generate container config file and configure mounts
    container_clp_config = clp_config.copy(deep=True)
    docker_clp_home = pathlib.Path(CONTAINER_CLP_INSTALL_PREFIX) / 'clp'
    mounts = [DockerMount(DockerMountType.BIND, clp_home, docker_clp_home)]

    input_logs_dfs_path = clp_config.input_logs_dfs_path.resolve()
    container_clp_config.input_logs_dfs_path = pathlib.Path('/') / 'mnt' / 'logs' / \
                                               input_logs_dfs_path.relative_to(input_logs_dfs_path.anchor)
    mounts.append(DockerMount(DockerMountType.BIND, input_logs_dfs_path,
                              container_clp_config.input_logs_dfs_path, True))

    if clp_config.data_directory.is_absolute():
        container_clp_config.data_directory = docker_clp_home / 'var' / 'data'
        mounts.append(DockerMount(DockerMountType.BIND, clp_config.data_directory, container_clp_config.data_directory))
    if clp_config.logs_directory.is_absolute():
        container_clp_config.logs_directory = docker_clp_home / 'var' / 'log'
        mounts.append(DockerMount(DockerMountType.BIND, clp_config.logs_directory, container_clp_config.logs_directory))
    if clp_config.archive_output.directory.is_absolute():
        container_clp_config.archive_output.directory = pathlib.Path('/') / 'mnt' / 'archive-output'
        mounts.append(DockerMount(DockerMountType.BIND, clp_config.archive_output.directory,
                                  container_clp_config.archive_output.directory))

    return container_clp_config, mounts


def validate_or_generate_config_file(config_file_path: pathlib.Path, default_config_file_path: pathlib.Path):
    # Validate config file path
    if config_file_path.exists():
        # Parse and validate config file
        clp_config = CLPConfig.parse_obj(read_yaml_config_file(config_file_path))
    else:
        if config_file_path != default_config_file_path:
            raise ValueError(f'Path specified for "--config" does not exist: {config_file_path}')

        # Generate config file
        clp_config = CLPConfig(
            input_logs_dfs_path=pathlib.Path('/'),
            database=Database(
                type='mariadb',
                host=f'127.0.0.1',
                port=find_available_port('127.0.0.1'),
                username='clp-user',
                password=f'{secrets.token_urlsafe(8)}',
                name='initial_database'
            ),
            scheduler=Scheduler(
                jobs_poll_delay=1
            ),
            scheduler_queue=SchedulerQueue(
                host=f'127.0.0.1',
                port=find_available_port('127.0.0.1'),
                username='clp-user',
                password=f'{secrets.token_urlsafe(8)}'
            ),
            archive_output=ArchiveOutput(
                type='fs',
                directory=pathlib.Path('var') / 'data' / 'archives',
                target_archive_size=268435456,
                target_dictionaries_size=33554432,
                target_encoded_file_size=268435456,
                target_segment_size=268435456
            ),
            data_directory=pathlib.Path('var') / 'data',
            logs_directory=pathlib.Path('var') / 'log'
        )

        with open(config_file_path, 'w') as f:
            f.write(clp_config.generate_config_file_content_with_comments())

    return clp_config


def make_config_path_absolute(clp_home: pathlib.Path, config_path: pathlib.Path):
    if config_path.is_absolute():
        return config_path
    else:
        return clp_home / config_path


def find_available_port(host: str):
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((host, 0))
        return sock.getsockname()[1]


def container_exists(container_name):
    check_container_exists_cmd = [
        'docker', 'ps', '-q', '-f', f'name={container_name}'
    ]
    proc = subprocess.run(check_container_exists_cmd, stdout=subprocess.PIPE)
    for line in proc.stdout.decode("utf-8"):
        if line != "":
            return True

    return False
